from flask import Flask, jsonify, request
from utils.string import String
from db_storage import DBstorage


app = Flask(__name__)
storage = DBstorage()

@app.route('/strings', methods=['POST'], strict_slashes=False)
def create_string():
	data = request.get_json()
	val = data.get('value')
	if not val:
		return jsonify({"Bad request": 'Invalid request body or missing "value" field'}), 400
	if not isinstance(val, str):
		return jsonify({'Unprocessable Entity': 'Invalid data type for "value" (must be string)'}), 422

	txt = String(val)
	if storage.find_string(data):
		return jsonify({'Conflict': 'String already exists in the system'}), 409
	print(storage.find_string(data))
	
	dic = {
			"value": val,
			"id": txt.hashed_value(),
			"properties": {
				"length": txt.length(),
				"is_palindrome": txt.is_palindrome(),
				"unique_characters": txt.unique_characters(),
				"word_count": txt.word_count(),
				"sha256_hash": txt.hashed_value(),
				"character_frequency_map": txt.character_frequency_map(),
			},
			"created_at": txt.created_at.strftime("%Y-%m-%d %H:%M:%S")
	}

	storage.save(dic)
	del dic["_id"]
	return jsonify(dic), 200 

def construct_filter(params):
	filters = {}
	for arg, val in params.items():
		if arg == "is_palindrome":
			if val == "True" or val == "False":
				filters["properties.is_palindrome"] = eval(val)
				params[arg] = eval(val)
			else:
				return [None, None]

		if arg == "min_length":
			try:
				filters["properties.length"] = {"$gte":int(val)}
				params[arg] = int(val)
			except ValueError:
				return [None, None]

		if arg == "max_length":
			try:
				filters["properties.length"] = {"$lte":int(val)}
				params[arg] = int(val)
			except ValueError:
				return [None, None]

		if arg == "word_count":
			try:
				filters["properties.word_count"] = int(val)
				params[arg] = int(val)
			except ValueError:
				return [None, None]

		if arg == "contains_character":
			filters["value"] = {"$regex": val, "$options": "i"}

	return [filters, params]


@app.route('/strings/<value>', methods=['GET'], strict_slashes=False)
def get_string(value):
	val = " ".join(value.split("_"))
	string_obj = storage.find_string({"value": val})
	if string_obj:
		del string_obj["_id"]
		return jsonify(string_obj), 200
	return jsonify({'Not Found': 'String does not exist in the system'}), 404



@app.route('/strings', methods=['GET'], strict_slashes=False)
def get_strings():
	filters = {}
	params = request.args.to_dict()

	for arg, val in params.items():
		if arg == "is_palindrome":
			if val == "True" or val == "False":
				filters["properties.is_palindrome"] = eval(val)
				params[arg] = eval(val)
			else:
				return jsonify({'Bad Request':  'Invalid query parameter values or types'}), 400

		if arg == "min_length":
			try:
				filters["properties.length"] = {"$gte":int(val)}
				params[arg] = int(val)
			except ValueError:
				return jsonify({'Bad Request':  'Invalid query parameter values or types'}), 400

		if arg == "max_length":
			try:
				filters["properties.length"] = {"$lte":int(val)}
				params[arg] = int(val)
			except ValueError:
				return jsonify({'Bad Request':  'Invalid query parameter values or types'}), 400

		if arg == "word_count":
			try:
				filters["properties.word_count"] = int(val)
				params[arg] = int(val)
			except ValueError:
				return jsonify({'Bad Request': 'Invalid query parameter values or types'}), 400

		if arg == "contains_character":
			filters["value"] = {"$regex": val, "$options": "i"}

	resp = {"data": []}
	for obj in storage.find_all(filters):
		del obj["_id"]
		resp["data"].append(obj)

	resp["filters_applied"] = params
	resp["count"] = len(resp["data"])
	return jsonify(resp), 200



@app.route('/strings/filter-by-natural-language', methods=['GET'], strict_slashes=False)
def get_strings_with_natural_language():
	query = request.args.get("query", '').lower().strip()
	if not query:
		return jsonify({'Bad Request' : 'Unable to parse natural language query1'}), 400
	params = {}

	try:
		if "palindromic" in query or "palindrome" in query:
			params["is_palindrome"] = "True"

		if "single word" in query or "one word" in query:
			params["word_count"] = 1
		elif "two words" in query:
			params["word_count"] = 2

		if "longer than" in query:
			try:
				num = int(query.split("longer than")[1].split()[0])
				params["min_length"] = num + 1
			except (IndexError, ValueError):
				return jsonify(error="Invalid length specification"), 400

		elif "shorter than" in query:
			try:
				num = int(query.split("shorter than")[1].split()[0])
				params["max_length"] = num - 1
			except (IndexError, ValueError):
				return jsonify(error="Invalid length specification"), 400

		if "containing the letter" in query:
			try:
				char = query.split("containing the letter")[1].strip().split()[0]
				params["contains_character"] = char[0]
			except IndexError:
				return jsonify(error="Invalid character specification"), 400

		elif "contain the first vowel" in query:
			filters["contains_character"] = "a"

		if ("min_length" in params and "max_length" in params and
			params["min_length"] > params["max_length"]):
			return jsonify(error="Conflicting filters"), 422

		if not params:
			return jsonify(error="Unable to parse natural language query2"), 400

		
		print(params)
		filters, args = construct_filter(params)

		if filters == None:
			return jsonify({'Bad Request': 'Unable to parse natural language query3'}), 400
		resp = {"data": []}
		for obj in storage.find_all(filters):
			del obj["_id"]
			resp["data"].append(obj)

		resp["count"] = len(resp["data"])
		dic = {
				"original": request.args.get("query"),
				"parsed_filters": args
		}
		resp["interpreted_query"] = dic
		return jsonify(resp)

	except Exception as e:
		return jsonify(error="Unable to parse natural language query4"), 400


if __name__ == '__main__':
	app.run(debug=True)
